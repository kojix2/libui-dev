diff --git a/compile_log.txt b/compile_log.txt
new file mode 100644
index 00000000..bfb30526
Binary files /dev/null and b/compile_log.txt differ
diff --git a/darwin/draw.h b/darwin/draw.h
index 382b7e77..47e05d35 100644
--- a/darwin/draw.h
+++ b/darwin/draw.h
@@ -6,3 +6,12 @@ struct uiDrawContext {
 	CGContextRef c;
 	CGFloat height;				// needed for text; see below
 };
+
+struct uiImageBuffer {
+	int Width;
+	int Height;
+	int Stride;
+
+	CGContextRef buf;
+	CGImageRef img;
+};
diff --git a/darwin/draw.m b/darwin/draw.m
index c6b4efcc..06f70c58 100644
--- a/darwin/draw.m
+++ b/darwin/draw.m
@@ -452,3 +452,98 @@ void uiDrawRestore(uiDrawContext *c)
 {
 	CGContextRestoreGState(c->c);
 }
+
+// ImageBuffer API
+
+uiImageBuffer *uiNewImageBuffer(uiDrawContext *c, int width, int height, int alpha)
+{
+	uiImageBuffer *buf;
+	CGColorSpaceRef color_space;
+	uint32_t alpha_info;
+
+	buf = uiprivNew(uiImageBuffer);
+	color_space = CGColorSpaceCreateDeviceRGB();
+	alpha_info = alpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;
+
+	buf->buf = CGBitmapContextCreate(NULL,
+		width, height,
+		8, width * 4, color_space,
+		alpha_info | kCGBitmapByteOrder32Little);
+	buf->img = CGBitmapContextCreateImage(buf->buf);
+	buf->Width = width;
+	buf->Height = height;
+	buf->Stride = width * 4;
+
+	CFRelease(color_space);
+	return buf;
+}
+
+void uiImageBufferUpdate(uiImageBuffer *buf, const void *data)
+{
+	uint8_t *src = (uint8_t *) data;
+	uint8_t *dst = (uint8_t *) CGBitmapContextGetData(buf->buf);
+	int x, y;
+
+	// convert RGBA to BGRA and flip vertically
+	dst += buf->Stride * (buf->Height - 1);
+	for (y = 0; y < buf->Height; y++) {
+		for (x = 0; x < buf->Width * 4; x += 4) {
+			union {
+				uint32_t v32;
+				uint8_t v8[4];
+			} v;
+
+			v.v32 = ((uint32_t) (src[x + 3])) << 24;
+			v.v32 |= ((uint32_t) (src[x])) << 16;
+			v.v32 |= ((uint32_t) (src[x + 1])) << 8;
+			v.v32 |= ((uint32_t) (src[x + 2]));
+			dst[x] = v.v8[0];
+			dst[x + 1] = v.v8[1];
+			dst[x + 2] = v.v8[2];
+			dst[x + 3] = v.v8[3];
+		}
+		src += buf->Width * 4;
+		dst -= buf->Stride;
+	}
+
+	CGImageRelease(buf->img);
+	buf->img = CGBitmapContextCreateImage(buf->buf);
+}
+
+static void drawImageBuffer(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect, CGInterpolationQuality interp)
+{
+	if (srcrect->Width == 0 || srcrect->Height == 0)
+		return;  // avoid dividing by zero
+
+	CGFloat sx = dstrect->Width / (CGFloat) srcrect->Width;
+	CGFloat sy = dstrect->Height / (CGFloat) srcrect->Height;
+	CGRect clip_rect = CGRectMake(dstrect->X, dstrect->Y, dstrect->Width, dstrect->Height);
+	CGRect draw_rect = CGRectMake(
+		dstrect->X - srcrect->X * sx,
+		dstrect->Y - srcrect->Y * sy,
+		buf->Width * sx,
+		buf->Height * sy);
+
+	CGContextSaveGState(c->c);
+	CGContextSetInterpolationQuality(c->c, interp);
+	CGContextClipToRect(c->c, clip_rect);
+	CGContextDrawImage(c->c, draw_rect, buf->img);
+	CGContextRestoreGState(c->c);
+}
+
+void uiImageBufferDraw(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect)
+{
+	drawImageBuffer(c, buf, srcrect, dstrect, kCGInterpolationHigh);
+}
+
+void uiImageBufferDrawFast(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect)
+{
+	drawImageBuffer(c, buf, srcrect, dstrect, kCGInterpolationLow);
+}
+
+void uiFreeImageBuffer(uiImageBuffer *buf)
+{
+	CGImageRelease(buf->img);
+	CGContextRelease(buf->buf);
+	uiprivFree(buf);
+}
diff --git a/test/qa/imagebuffer.c b/test/qa/imagebuffer.c
new file mode 100644
index 00000000..93b81404
--- /dev/null
+++ b/test/qa/imagebuffer.c
@@ -0,0 +1,196 @@
+#include "qa.h"
+
+static uiAreaHandler handler;
+
+const char *imageBufferTransformGuide() {
+	return
+	"1.\tThe first image should be a tiny yellow icon in the top left corner.\n"
+	"\n"
+	"2.\tThe second image should be twice larger than the first one.\n"
+	"\tAnd it should be rotated by 45 degrees clockwise.\n"
+	"\n"
+	"3.\tThe third image should be the same as the second one,\n"
+	"\tbut it should also have black edges.\n"
+	;
+}
+
+// 16 * 16 image. It's the same as dat0[] in libui-ng/test/images.c
+// The original png image is libui-ng/test/andlabs_16x16test_24june2016.png
+static const uint8_t dat0[] = {
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xE5, 0x60, 0xFC, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xE5, 0x60, 0xFC, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xE5, 0x60, 0xFC, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xE5, 0x60, 0xFC, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
+	0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+};
+
+// helper to quickly set a brush color
+static void SetSolidBrush(uiDrawBrush *brush, uint32_t color, double alpha)
+{
+	uint8_t component;
+
+	brush->Type = uiDrawBrushTypeSolid;
+	component = (uint8_t) ((color >> 16) & 0xFF);
+	brush->R = ((double) component) / 255;
+	component = (uint8_t) ((color >> 8) & 0xFF);
+	brush->G = ((double) component) / 255;
+	component = (uint8_t) (color & 0xFF);
+	brush->B = ((double) component) / 255;
+	brush->A = alpha;
+}
+
+static void handlerDraw(uiAreaHandler *a, uiArea *area, uiAreaDrawParams *p)
+{
+	// fill the area
+	uiDrawPath *path;
+	uiDrawBrush brush;
+	SetSolidBrush(&brush, 0xFFFFFF, 1.0);
+	path = uiDrawNewPath(uiDrawFillModeWinding);
+	uiDrawPathAddRectangle(path, 0, 0, p->AreaWidth, p->AreaHeight);
+	uiDrawPathEnd(path);
+	uiDrawFill(p->Context, path, &brush);
+	uiDrawFreePath(path);
+
+	uiImageBuffer* image = uiNewImageBuffer(p->Context, 16, 16, 1);
+	uiImageBufferUpdate(image, dat0);
+	uiRect src_rect = { 0, 0, 16, 16 };
+
+	// first image
+	uiImageBufferDraw(p->Context, image, &src_rect, &src_rect);
+
+	// second image (test with uiDrawTransform)
+	uiDrawSave(p->Context);
+
+	uiDrawMatrix tm, rm;
+	uiDrawMatrixSetIdentity(&tm);
+	uiDrawMatrixTranslate(&tm, 32, 4);
+	uiDrawTransform(p->Context, &tm);
+	uiDrawMatrixSetIdentity(&rm);
+	uiDrawMatrixRotate(&rm, 16, 16, uiPi / 4);
+	uiDrawTransform(p->Context, &rm);
+
+	uiRect dst_rect = { 0, 8, 32, 32 };
+	uiImageBufferDraw(p->Context, image, &src_rect, &dst_rect);
+
+	uiDrawRestore(p->Context);
+
+	// third image (test if uiImageBufferDraw has the same transformation as uiDrawPath)
+	uiDrawMatrixSetIdentity(&tm);
+	uiDrawMatrixTranslate(&tm, 80, 4);
+	uiDrawTransform(p->Context, &tm);
+	uiDrawTransform(p->Context, &rm);
+
+	SetSolidBrush(&brush, 0x000000, 1.0);
+	path = uiDrawNewPath(uiDrawFillModeWinding);
+	uiDrawPathAddRectangle(path, -2, 6, 36, 36);
+	uiDrawPathEnd(path);
+	uiDrawFill(p->Context, path, &brush);
+	uiDrawFreePath(path);
+
+	uiImageBufferDraw(p->Context, image, &src_rect, &dst_rect);
+
+	uiFreeImageBuffer(image);
+}
+
+static void handlerMouseEvent(uiAreaHandler *a, uiArea *area, uiAreaMouseEvent *e)
+{
+	// do nothing
+}
+
+static void handlerMouseCrossed(uiAreaHandler *ah, uiArea *a, int left)
+{
+	// do nothing
+}
+
+static void handlerDragBroken(uiAreaHandler *ah, uiArea *a)
+{
+	// do nothing
+}
+
+static int handlerKeyEvent(uiAreaHandler *ah, uiArea *a, uiAreaKeyEvent *e)
+{
+	// reject all keys
+	return 0;
+}
+
+uiControl* imageBufferTransform()
+{
+	uiBox *vbox;
+	uiLabel *label;
+
+	vbox = uiNewVerticalBox();
+	uiBoxSetPadded(vbox, 1);
+
+	handler.Draw = handlerDraw;
+	handler.MouseEvent = handlerMouseEvent;
+	handler.MouseCrossed = handlerMouseCrossed;
+	handler.DragBroken = handlerDragBroken;
+	handler.KeyEvent = handlerKeyEvent;
+
+	uiArea *area = uiNewArea(&handler);
+	uiBoxAppend(vbox, uiControl(area), 1);
+
+	label = uiNewLabel("\n\n\n");  // It can make space for uiArea
+	uiBoxAppend(vbox, uiControl(label), 1);
+
+	return uiControl(vbox);
+}
diff --git a/test/qa/main.c b/test/qa/main.c
index d83d384d..230de4c7 100644
--- a/test/qa/main.c
+++ b/test/qa/main.c
@@ -39,6 +39,11 @@ struct controlTestCase labelTestCases[] = {
 	{NULL, NULL, NULL}
 };
 
+struct controlTestCase imageBufferTestCases[] = {
+	QA_TEST("1. Transformation", imageBufferTransform),
+	{NULL, NULL, NULL}
+};
+
 struct controlTestCase windowTestCases[] = {
 	QA_TEST("1. Fullscreen", windowFullscreen),
 	QA_TEST("2. Borderless", windowBorderless),
@@ -54,6 +59,7 @@ struct controlTestGroup controlTestGroups[] = {
 	{"uiCheckbox", checkboxTestCases},
 	{"uiEntry", entryTestCases},
 	{"uiLabel", labelTestCases},
+	{"uiImageBuffer", imageBufferTestCases},
 	{"uiWindow", windowTestCases},
 };
 
diff --git a/test/qa/meson.build b/test/qa/meson.build
index fd0c6d84..8dede726 100644
--- a/test/qa/meson.build
+++ b/test/qa/meson.build
@@ -5,6 +5,7 @@ libui_qa_sources = [
 	'checkbox.c',
 	'entry.c',
 	'label.c',
+	'imagebuffer.c',
 	'window.c',
 ]
 
diff --git a/test/qa/qa.h b/test/qa/qa.h
index 3543d95a..3b2cfc0a 100644
--- a/test/qa/qa.h
+++ b/test/qa/qa.h
@@ -22,6 +22,7 @@ QA_DECLARE_TEST(entryOverflowText);
 
 QA_DECLARE_TEST(labelMultiLine);
 
+QA_DECLARE_TEST(imageBufferTransform);
 
 QA_DECLARE_TEST(windowFullscreen);
 QA_DECLARE_TEST(windowBorderless);
diff --git a/test/unit/imagebuffer.c b/test/unit/imagebuffer.c
new file mode 100644
index 00000000..be4773c7
--- /dev/null
+++ b/test/unit/imagebuffer.c
@@ -0,0 +1,189 @@
+#include "unit.h"
+
+#define uiAreaPtrFromState(s) uiControlPtrFromState(uiArea, s)
+
+static uiAreaHandler handler;
+
+// 16 * 16 image. It's the same as dat0[] in libui-ng/test/images.c
+// The original png image is libui-ng/test/andlabs_16x16test_24june2016.png
+static const uint8_t dat0[] = {
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xE5, 0x60, 0xFC, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xE5, 0x60, 0xFC, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xE5, 0x60, 0xFC, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xE5, 0x60, 0xFC, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
+	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
+	0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
+	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
+};
+
+static void handlerMouseEvent(uiAreaHandler *a, uiArea *area, uiAreaMouseEvent *e)
+{
+	// do nothing
+}
+
+static void handlerMouseCrossed(uiAreaHandler *ah, uiArea *a, int left)
+{
+	// do nothing
+}
+
+static void handlerDragBroken(uiAreaHandler *ah, uiArea *a)
+{
+	// do nothing
+}
+
+static int handlerKeyEvent(uiAreaHandler *ah, uiArea *a, uiAreaKeyEvent *e)
+{
+	// reject all keys
+	return 0;
+}
+
+static void handlerDrawDefault(uiAreaHandler *a, uiArea *area, uiAreaDrawParams *p)
+{
+	uiImageBuffer* image = uiNewImageBuffer(p->Context, 16, 16, 1);
+	uiRect rect = { 0, 0, 16, 16 };
+	uiImageBufferDraw(p->Context, image, &rect, &rect);
+	uiFreeImageBuffer(image);
+}
+
+static void imageBufferDefault(void **state)
+{
+	uiArea **a = uiAreaPtrFromState(state);
+	handler.Draw = handlerDrawDefault;
+	*a = uiNewArea(&handler);
+}
+
+static void handlerDrawUpdate(uiAreaHandler *a, uiArea *area, uiAreaDrawParams *p)
+{
+	uiImageBuffer* image = uiNewImageBuffer(p->Context, 16, 16, 1);
+	uiRect rect = { 0, 0, 16, 16 };
+	uiImageBufferUpdate(image, dat0);
+	uiImageBufferDraw(p->Context, image, &rect, &rect);
+	uiFreeImageBuffer(image);
+}
+
+static void imageBufferUpdate(void **state)
+{
+	uiArea **a = uiAreaPtrFromState(state);
+	handler.Draw = handlerDrawUpdate;
+	*a = uiNewArea(&handler);
+}
+
+static void handlerDrawZeroSizedRect(uiAreaHandler *a, uiArea *area, uiAreaDrawParams *p)
+{
+	uiImageBuffer* image = uiNewImageBuffer(p->Context, 16, 16, 1);
+	uiImageBufferUpdate(image, dat0);
+	uiRect rect = { 0, 0, 16, 16 };
+	uiRect zero_rect = { 0, 0, 0, 0 };
+	uiImageBufferDraw(p->Context, image, &rect, &zero_rect);
+	uiImageBufferDraw(p->Context, image, &zero_rect, &rect);
+	uiFreeImageBuffer(image);
+}
+
+static void imageBufferZeroSizedRect(void **state)
+{
+	uiArea **a = uiAreaPtrFromState(state);
+	handler.Draw = handlerDrawZeroSizedRect;
+	*a = uiNewArea(&handler);
+}
+
+static void handlerDrawFast(uiAreaHandler *a, uiArea *area, uiAreaDrawParams *p)
+{
+	uiImageBuffer* image = uiNewImageBuffer(p->Context, 16, 16, 1);
+	uiRect rect = { 0, 0, 16, 16 };
+	uiImageBufferUpdate(image, dat0);
+	uiImageBufferDrawFast(p->Context, image, &rect, &rect);
+	uiFreeImageBuffer(image);
+}
+
+static void imageBufferFast(void **state)
+{
+	uiArea **a = uiAreaPtrFromState(state);
+	handler.Draw = handlerDrawFast;
+	*a = uiNewArea(&handler);
+}
+
+static int imageBufferTestSetup(void **state)
+{
+	int rv = unitTestSetup(state);
+	if (rv != 0)
+		return rv;
+
+	handler.MouseEvent = handlerMouseEvent;
+	handler.MouseCrossed = handlerMouseCrossed;
+	handler.DragBroken = handlerDragBroken;
+	handler.KeyEvent = handlerKeyEvent;
+
+	return 0;
+}
+
+#define imageBufferUnitTest(f) cmocka_unit_test_setup_teardown((f), \
+		imageBufferTestSetup, unitTestTeardown)
+
+int imageBufferRunUnitTests(void)
+{
+	const struct CMUnitTest tests[] = {
+		imageBufferUnitTest(imageBufferDefault),
+		imageBufferUnitTest(imageBufferUpdate),
+		imageBufferUnitTest(imageBufferZeroSizedRect),
+		imageBufferUnitTest(imageBufferFast),
+	};
+
+	return cmocka_run_group_tests_name("uiImageBuffer", tests, unitTestsSetup, unitTestsTeardown);
+}
diff --git a/test/unit/main.c b/test/unit/main.c
index bd3b1b3e..bb16d333 100644
--- a/test/unit/main.c
+++ b/test/unit/main.c
@@ -67,6 +67,7 @@ int main(void)
 		{ radioButtonsRunUnitTests },
 		{ entryRunUnitTests },
 		{ progressBarRunUnitTests },
+		{ imageBufferRunUnitTests },
 	};
 
 	for (i = 0; i < sizeof(unitTests)/sizeof(*unitTests); ++i) {
diff --git a/test/unit/meson.build b/test/unit/meson.build
index 0a8dcb7b..8876734b 100644
--- a/test/unit/meson.build
+++ b/test/unit/meson.build
@@ -14,6 +14,7 @@ libui_unit_sources = [
         'entry.c',
         'menu.c',
         'progressbar.c',
+		'imagebuffer.c',
 ]
 
 if libui_OS == 'windows'
diff --git a/test/unit/unit.h b/test/unit/unit.h
index 4f76aa12..a7a9a02e 100644
--- a/test/unit/unit.h
+++ b/test/unit/unit.h
@@ -24,6 +24,7 @@ int radioButtonsRunUnitTests(void);
 int entryRunUnitTests(void);
 int menuRunUnitTests(void);
 int progressBarRunUnitTests(void);
+int imageBufferRunUnitTests(void);
 
 /**
  * Helper for general setup/teardown of controls embedded in a window.
diff --git a/ui.h b/ui.h
index cfb801e3..e17faec7 100644
--- a/ui.h
+++ b/ui.h
@@ -2159,6 +2159,15 @@ struct uiDrawStrokeParams {
 	double DashPhase;
 };
 
+struct uiRect {
+	int X;
+	int Y;
+	int Width;
+	int Height;
+};
+
+typedef struct uiRect uiRect;
+
 _UI_EXTERN uiDrawPath *uiDrawNewPath(uiDrawFillMode fillMode);
 _UI_EXTERN void uiDrawFreePath(uiDrawPath *p);
 
@@ -2206,6 +2215,69 @@ _UI_EXTERN void uiDrawClip(uiDrawContext *c, uiDrawPath *path);
 _UI_EXTERN void uiDrawSave(uiDrawContext *c);
 _UI_EXTERN void uiDrawRestore(uiDrawContext *c);
 
+/**
+ * A class for storing an image to be drawn on uiDrawContext.
+ *
+ * @struct uiImageBuffer
+ */
+typedef struct uiImageBuffer uiImageBuffer;
+
+/**
+ * Creates a new image buffer instance.
+ *
+ * @param c uiDrawContext instance.
+ * @param width Image width in pixels.
+ * @param height Image height in pixels.
+ * @param alpha `TRUE` to use alpha channel, `FALSE` otherwise.
+ * @returns A new uiImageBuffer instance.
+ * @memberof uiImageBuffer
+ */
+_UI_EXTERN uiImageBuffer *uiNewImageBuffer(uiDrawContext *c, int width, int height, int alpha);
+
+/**
+ * Copies a byte array to the image buffer.
+ *
+ * @param buf uiImageBuffer instance.
+ * @param data Byte array of premultiplied pixels in [R G B A] order.\n
+ *             `((uint8_t *) data)[0]` equals the **R** of the first pixel,
+ *             `[3]` the **A** of the first pixel.\n
+ *             `data` must be at least `buf->Width * buf->Height * 4` bytes long.\n
+ *             Data is copied internally. Ownership is not transferred.
+ * @memberof uiImageBuffer
+ */
+_UI_EXTERN void uiImageBufferUpdate(uiImageBuffer *buf, const void *data);
+
+/**
+ * Draws the image buffer on the draw context with the highest quality interpolation.
+ *
+ * @param c uiDrawContext instance.
+ * @param buf uiImageBuffer instance.
+ * @param scrrect The size and position in the image buffer.
+ * @param dstrect The size and position in the draw context.
+ * @note Use uiImageBufferFast() if you want to use faster interpolation.
+ * @memberof uiImageBuffer
+ */
+_UI_EXTERN void uiImageBufferDraw(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect);
+
+/**
+ * Draws the image buffer on the draw context with the fastest interpolation.
+ *
+ * @param c uiDrawContext instance.
+ * @param buf uiImageBuffer instance.
+ * @param scrrect The size and position in the image buffer.
+ * @param dstrect The size and position in the draw context.
+ * @memberof uiImageBuffer
+ */
+_UI_EXTERN void uiImageBufferDrawFast(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect);
+
+/**
+ * Frees the image buffer and all associated resources.
+ *
+ * @param buf uiImageBuffer instance.
+ * @memberof uiImageBuffer
+ */
+_UI_EXTERN void uiFreeImageBuffer(uiImageBuffer *buf);
+
 // uiAttribute stores information about an attribute in a
 // uiAttributedString.
 //
diff --git a/unix/draw.c b/unix/draw.c
index a8f26d7f..dd023bf6 100644
--- a/unix/draw.c
+++ b/unix/draw.c
@@ -141,3 +141,92 @@ void uiDrawRestore(uiDrawContext *c)
 {
 	cairo_restore(c->cr);
 }
+
+// ImageBuffer API
+
+uiImageBuffer *uiNewImageBuffer(uiDrawContext *c, int width, int height, int alpha)
+{
+	uiImageBuffer *buf;
+
+	buf = uiprivNew(uiImageBuffer);
+
+	buf->buf = cairo_image_surface_create(alpha ? CAIRO_FORMAT_ARGB32 : CAIRO_FORMAT_RGB24, width, height);
+	if (cairo_surface_status(buf->buf) != CAIRO_STATUS_SUCCESS)
+		uiprivImplBug("error creating ImageBuffer: %s",
+			cairo_status_to_string(cairo_surface_status(buf->buf)));
+
+	buf->Width = width;
+	buf->Height = height;
+	buf->Stride = cairo_image_surface_get_stride(buf->buf);
+
+	return buf;
+}
+
+void uiImageBufferUpdate(uiImageBuffer *buf, const void *data)
+{
+	unsigned char *src = (unsigned char *) data;
+	unsigned char *dst = cairo_image_surface_get_data(buf->buf);
+	int x, y;
+
+	// convert RGBA to BGRA
+	for (y = 0; y < buf->Height; y++) {
+		for (x = 0; x < buf->Width * 4; x += 4) {
+			union {
+				uint32_t v32;
+				uint8_t v8[4];
+			} v;
+
+			v.v32 = ((uint32_t) (src[x + 3])) << 24;
+			v.v32 |= ((uint32_t) (src[x])) << 16;
+			v.v32 |= ((uint32_t) (src[x + 1])) << 8;
+			v.v32 |= ((uint32_t) (src[x + 2]));
+			dst[x] = v.v8[0];
+			dst[x + 1] = v.v8[1];
+			dst[x + 2] = v.v8[2];
+			dst[x + 3] = v.v8[3];
+		}
+		src += buf->Width * 4;
+		dst += buf->Stride;
+	}
+
+	cairo_surface_mark_dirty(buf->buf);
+}
+
+static void drawImageBuffer(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect, cairo_filter_t interp)
+{
+	if (srcrect->Width == 0 || srcrect->Height == 0)
+		return;  // avoid dividing by zero
+
+	cairo_save(c->cr);
+	cairo_rectangle(c->cr, dstrect->X, dstrect->Y, dstrect->Width, dstrect->Height);
+
+	cairo_translate(c->cr, dstrect->X, dstrect->Y);
+	if ((dstrect->Width != srcrect->Width) || (dstrect->Height != srcrect->Height))	{
+		double sx = dstrect->Width / (double)srcrect->Width;
+		double sy = dstrect->Height / (double)srcrect->Height;
+		cairo_scale(c->cr, sx, sy);
+	}
+
+	cairo_set_source_surface(c->cr, buf->buf, -srcrect->X, -srcrect->Y);
+	cairo_pattern_set_filter(cairo_get_source(c->cr), interp);
+	cairo_clip(c->cr);
+	cairo_paint(c->cr);
+
+	cairo_restore(c->cr);
+}
+
+void uiImageBufferDraw(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect)
+{
+	drawImageBuffer(c, buf, srcrect, dstrect, CAIRO_FILTER_BEST);
+}
+
+void uiImageBufferDrawFast(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect)
+{
+	drawImageBuffer(c, buf, srcrect, dstrect, CAIRO_FILTER_NEAREST);
+}
+
+void uiFreeImageBuffer(uiImageBuffer *buf)
+{
+	cairo_surface_destroy(buf->buf);
+	uiprivFree(buf);
+}
diff --git a/unix/draw.h b/unix/draw.h
index d46d074f..a8fd7222 100644
--- a/unix/draw.h
+++ b/unix/draw.h
@@ -6,6 +6,14 @@ struct uiDrawContext {
 	GtkStyleContext *style;
 };
 
+struct uiImageBuffer {
+	int Width;
+	int Height;
+	int Stride;
+
+	cairo_surface_t *buf;
+};
+
 // drawpath.c
 extern void uiprivRunPath(uiDrawPath *p, cairo_t *cr);
 extern uiDrawFillMode uiprivPathFillMode(uiDrawPath *path);
diff --git a/windows/draw.cpp b/windows/draw.cpp
index a5e5033a..e7b1e27b 100644
--- a/windows/draw.cpp
+++ b/windows/draw.cpp
@@ -509,3 +509,61 @@ void uiDrawRestore(uiDrawContext *c)
 	// no need to explicitly addref or release; just transfer the ref
 	c->currentClip = state.clip;
 }
+
+
+// ImageBuffer API
+
+uiImageBuffer *uiNewImageBuffer(uiDrawContext *c, int width, int height, int alpha)
+{
+	uiImageBuffer *buf;
+	HRESULT hr;
+
+	buf = uiprivNew(uiImageBuffer);
+
+	D2D1_BITMAP_PROPERTIES bp2 = D2D1::BitmapProperties();
+	bp2.dpiX = 0;
+	bp2.dpiY = 0;
+	bp2.pixelFormat = D2D1::PixelFormat(DXGI_FORMAT_R8G8B8A8_UNORM,
+				alpha ? D2D1_ALPHA_MODE_PREMULTIPLIED : D2D1_ALPHA_MODE_IGNORE);
+
+	hr = c->rt->CreateBitmap(D2D1::SizeU(width,height), NULL, 0, &bp2, &buf->buf);
+	if (hr != S_OK)
+		logHRESULT(L"error creating ImageBuffer", hr);
+
+	buf->Width = width;
+	buf->Height = height;
+	buf->Stride = width * 4;
+
+	return buf;
+}
+
+void uiImageBufferUpdate(uiImageBuffer *buf, const void *data)
+{
+	D2D1_RECT_U rekt = D2D1::RectU(0, 0, buf->Width, buf->Height);
+	buf->buf->CopyFromMemory(&rekt, data, buf->Stride);
+}
+
+static void drawImageBuffer(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect, D2D1_BITMAP_INTERPOLATION_MODE interp)
+{
+	D2D_RECT_F _srcrect = D2D1::RectF(srcrect->X, srcrect->Y, srcrect->X+srcrect->Width, srcrect->Y+srcrect->Height);
+	D2D_RECT_F _dstrect = D2D1::RectF(dstrect->X, dstrect->Y, dstrect->X+dstrect->Width, dstrect->Y+dstrect->Height);
+	c->rt->DrawBitmap(buf->buf, &_dstrect, 1.0f, interp, &_srcrect);
+}
+
+void uiImageBufferDraw(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect)
+{
+	// TODO Use D2D1_INTERPOLATION_MODE_CUBIC on Windows 8 or later.
+	// https://learn.microsoft.com/en-us/windows/win32/api/d2d1_1/ne-d2d1_1-d2d1_interpolation_mode
+	drawImageBuffer(c, buf, srcrect, dstrect, D2D1_BITMAP_INTERPOLATION_MODE_LINEAR);
+}
+
+void uiImageBufferDrawFast(uiDrawContext *c, uiImageBuffer *buf, uiRect *srcrect, uiRect *dstrect)
+{
+	drawImageBuffer(c, buf, srcrect, dstrect, D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR);
+}
+
+void uiFreeImageBuffer(uiImageBuffer *buf)
+{
+	buf->buf->Release();
+	uiprivFree(buf);
+}
diff --git a/windows/draw.hpp b/windows/draw.hpp
index c7c94b61..9912deb8 100644
--- a/windows/draw.hpp
+++ b/windows/draw.hpp
@@ -12,6 +12,14 @@ struct uiDrawContext {
 	ID2D1PathGeometry *currentClip;
 };
 
+struct uiImageBuffer {
+	int Width;
+	int Height;
+	int Stride;
+
+	ID2D1Bitmap *buf;
+};
+
 // drawpath.cpp
 extern ID2D1PathGeometry *pathGeometry(uiDrawPath *p);
 
